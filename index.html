<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
  <title>CMRA — Heatmap + Iso-densité (23k points)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html, body { height: 100%; margin: 0; }

    /* IMPORTANT : position:relative pour que les cartouches soient DANS la carte */
    #map {
      height: 100%;
      width: 100%;
      position: relative;
      overflow: hidden; 
    }

    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: rgba(255, 255, 255, 0.92);
      padding: 10px 12px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 13px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.12);
      max-width: 380px;
    }

    .toolbar label { display: block; margin: 6px 0 2px; }
    .toolbar input[type="range"] { width: 100%; }

    .toolbar .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .toolbar button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
    }

    .toolbar small {
      color: #555;
      display: block;
      margin-top: 8px;
      line-height: 1.25;
    }

    .stat { margin-top: 6px; color: #333; }

    /* ------------------------------------------------------------------ */
    /* Cartouches d'impression (doivent être INSIDE #map pour l'export PNG) */
    /* ------------------------------------------------------------------ */
    .print-title {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      text-transform: uppercase;
      z-index: 99999;

      background: rgba(255,255,255,0.85);
      padding: 6px 14px;
      border-radius: 12px;

      font-size: 13px;
      font-weight: 650;
      letter-spacing: 0.04em;

      pointer-events: none;
      white-space: nowrap;
    }

    .print-credit {
      position: absolute;
      left: 12px;
      bottom: 12px;
      z-index: 99999;
      background: rgba(255,255,255,0.85);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      line-height: 1.25;
      max-width: 68%;
      pointer-events: none;
    }

    .print-scale {
      position: absolute;
      right: 12px;
      bottom: 12px;
      z-index: 99999;
      background: rgba(255,255,255,0.85);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      line-height: 1.1;
      min-width: 160px;
      pointer-events: none;
    }

    .print-scale .bar {
      height: 6px;
      width: 140px;
      background: #111;
      border-radius: 2px;
      margin-bottom: 4px;
      opacity: 0.85;
    }

    .print-scale .txt {
      text-align: center;
      white-space: nowrap;
    }

    .print-title, .print-credit, .print-scale { backdrop-filter: blur(2px); }
  </style>
</head>

<body>
  <div class="toolbar">
    <div><b>CMRA — heatmap + iso-densité</b></div>

    <label for="bgOpacity">Opacité fond</label>
    <input id="bgOpacity" type="range" min="0" max="1" step="0.05" value="0.65" />

    <label for="heatRadius">Rayon heatmap</label>
    <input id="heatRadius" type="range" min="6" max="50" step="1" value="18" />

    <label for="cellKm">Pas grille densité (km)</label>
    <input id="cellKm" type="range" min="5" max="80" step="1" value="20" />

    <label for="sigma">Lissage (sigma, en cellules)</label>
    <input id="sigma" type="range" min="0" max="4" step="0.5" value="2" />

    <label for="isoColor">Couleur isolignes</label>
    <input id="isoColor" type="color" value="#6fe7ff" />

    <hr />

    <label><input id="toggleIso" type="checkbox" checked /> Isolignes</label>
    <label><input id="toggleCredit" type="checkbox" checked /> Cartouche crédits</label>
    <label><input id="toggleRivers" type="checkbox" checked /> Rivières</label>
    <label><input id="toggleRiversOut" type="checkbox" checked/> Rivières (hors Imperium)</label>
    <label><input id="toggleRoutes" type="checkbox" checked /> Routes</label>
    <label><input id="toggleLakes" type="checkbox" checked/> Lacs</label>
    <label><input id="togglePlaces" type="checkbox" checked/> Villes (points)</label>
    <label><input id="toggleFinds" type="checkbox" /> Points de découverte (bruts)</label>

    <label for="findRadius">Taille points découverte</label>
    <input id="findRadius" type="range" min="1" max="6" step="1" value="2" />

    <label for="findOpacity">Opacité points découverte</label>
    <input id="findOpacity" type="range" min="0.05" max="1" step="0.05" value="0.65" />

    <hr />
    <label><input id="toggleLog" type="checkbox" /> Densité en échelle logarithmique (iso)</label>
    
    <div class="row">
      <button id="rebuild" type="button">Recalculer iso-densité</button>
      <button id="exportPng" type="button">Exporter PNG (HD)</button>
    </div>

    <div class="stat" id="stat">Chargement…</div>
  </div>

  <!-- IMPORTANT : cartouches INSIDE la map -->
  <div id="map">
    <div id="printTitle" class="print-title">projet-cmra — 2026 – P. Ciezar</div>

    <div id="printCredit" class="print-credit">
      Fond : Digital Atlas of the Roman Empire (DARE) — © Johan Ahlfeldt (miroir).<br>
      Données : CMRA — © P. Van Ossel, L. Bakker, P. Ciezar (coll.).<br>
      Carte : heatmap + iso-densité.
    </div>

    <div id="printScale" class="print-scale">
      <div class="bar"></div>
      <div class="txt" id="printScaleTxt">Échelle</div>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/d3-contour@4"></script>

  <!-- Export -->
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Données externes (scripts JS qui définissent des variables globales) -->
  <script src="https://czr-pablo.github.io/rivers.geojson"></script>
  <script src="https://czr-pablo.github.io/rivershorsImperium.geojson"></script>
  <script src="https://czr-pablo.github.io/routes.geojson"></script>
  <script src="https://czr-pablo.github.io/lakes.geojson"></script>
  <script src="https://czr-pablo.github.io/places.geojson"></script>

  <script>
    // -------------------------------------------------------------------------
    // Config générale
    // -------------------------------------------------------------------------
    const mapBounds = L.latLngBounds(
      L.latLng(-0.00038285, -16.25),
      L.latLng(69.99997914, 60.00076508)
    );

    const mapMinZoom = 1;
    const mapMaxZoom = 14;

    // Styles iso (scope global)
    let ISO_COLOR = "#6fe7ff";
    let ISO_OPACITY = 0.9;
    let ISO_WEIGHT = 1.1;

    // Layers dynamiques
    let heatLayer = null;
    let isoLayer = null;
    let cachedPoints = [];
    let layerFinds = null;

    const findsRenderer = L.canvas({ padding: 0.5, pane: "paneFinds", tolerance: 0 });

    const statEl = document.getElementById("stat");

    // -------------------------------------------------------------------------
    // Map init
    // -------------------------------------------------------------------------
    const map = L.map("map", { 
      zoomDelta: 0.5, 
      zoomSnap: 0,
      preferCanvas: true  // IMPORTANT pour export
    }).setView([48.84664, 2.36481], 5.75);

    // -------------------------------------------------------------------------
    // Panes Leaflet (ordre des calques)
    // -------------------------------------------------------------------------
    map.createPane("paneIso");      // isolignes (courbes de niveau)
    map.getPane("paneIso").style.zIndex = 650;

    map.createPane("panePlaces");   // villes
    map.getPane("panePlaces").style.zIndex = 660;

    map.createPane("paneFinds");    // points bruts (découvertes)
    map.getPane("paneFinds").style.zIndex = 670;

    const hillshade = L.tileLayer(
      "https://corpus-argonne-fond.netlify.app/hillshade/{z}/{x}/{y}.png",
      {
        minZoom: mapMinZoom,
        maxZoom: mapMaxZoom,
        bounds: mapBounds,
        attribution: "Tiles: DARE (Ahlfeldt) — miroir Netlify"
      }
    ).addTo(map);

    const background = L.tileLayer(
      "https://corpus-argonne-fond.netlify.app/background/{z}/{x}/{y}.jpg",
      {
        minZoom: mapMinZoom,
        maxZoom: mapMaxZoom,
        bounds: mapBounds,
        opacity: 0.65
      }
    ).addTo(map);

    // Zoom UI (outils + / -)
    L.control.zoom({ position: "topright" }).addTo(map);

    // Échelle Leaflet
    L.control.scale({ imperial: false, position: "bottomright" }).addTo(map);

    // -------------------------------------------------------------------------
    // Cartouche échelle (capture PNG)
    // -------------------------------------------------------------------------
    function roundNiceMeters(m) {
      const steps = [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000];
      let best = steps[0];
      for (const s of steps) if (s <= m) best = s;
      return best;
    }

    function updatePrintScale() {
      const px = 140;
      const p1 = map.containerPointToLatLng([20, 20]);
      const p2 = map.containerPointToLatLng([20 + px, 20]);

      const meters = map.distance(p1, p2);
      const nice = roundNiceMeters(meters);

      const ratio = nice / meters;
      const newPx = Math.max(60, Math.min(260, Math.round(px * ratio)));

      const bar = document.querySelector("#printScale .bar");
      bar.style.width = `${newPx}px`;

      const txt = document.getElementById("printScaleTxt");
      txt.textContent = (nice >= 1000)
        ? `${(nice / 1000).toLocaleString("fr-FR")} km`
        : `${nice.toLocaleString("fr-FR")} m`;
    }

    map.on("zoomend moveend", updatePrintScale);
    updatePrintScale();

    // -------------------------------------------------------------------------
    // Couches externes (variables globales)
    // -------------------------------------------------------------------------
    let layerRivers = null;
    let layerRiversOut = null;
    let layerRoutes = null;
    let layerLakes = null;
    let layerPlaces = null;

    function initExternalLayersFromGlobals() {
      if (typeof rivieres !== "undefined") {
        layerRivers = L.geoJSON(rivieres, {
          style: { color: "#2764bf", opacity: 0.45, weight: 1.5 }
        });
      }

      if (typeof autresfleuves !== "undefined") {
        layerRiversOut = L.geoJSON(autresfleuves, {
          style: { color: "#2764bf", opacity: 0.45, weight: 1.5 }
        });
      }

      if (typeof route !== "undefined") {
        layerRoutes = L.geoJSON(route, {
          style: { color: "#771b1b", opacity: 0.45, weight: 1 }
        });
      }

      if (typeof lakes !== "undefined") {
        layerLakes = L.geoJSON(lakes, {
          style: {
            fillColor: "#2764bf",
            color: "#000",
            weight: 0.5,
            opacity: 0,
            fillOpacity: 0.5
          }
        });
      }

      if (typeof places !== "undefined") {
        layerPlaces = L.geoJSON(places, {
          pane: "panePlaces",
          onEachFeature: (feature, layer) => {
            if (feature.properties?.modern) {
              layer.bindPopup(`${feature.properties.modern} / ${feature.properties.latin ?? ""}`);
            }
          },
          pointToLayer: (_feature, latlng) => L.circleMarker(latlng, {
            pane: "panePlaces",
            radius: 3,
            fillColor: "#c2bcbc",
            color: "#000",
            weight: 0.7,
            opacity: 0.6,
            fillOpacity: 1,
          })
        });
      }
    }

    function setLayerVisible(layer, on) {
      if (!layer) return;
      if (on) layer.addTo(map);
      else map.removeLayer(layer);
    }

    initExternalLayersFromGlobals();

    // -------------------------------------------------------------------------
    // UI bindings
    // -------------------------------------------------------------------------
    document.getElementById("bgOpacity").addEventListener("input", (e) => {
      background.setOpacity(parseFloat(e.target.value));
    });

    document.getElementById("heatRadius").addEventListener("input", () => {
      drawHeat(cachedPoints);
    });

    document.getElementById("isoColor").addEventListener("input", (e) => {
      ISO_COLOR = e.target.value;
      if (isoLayer) isoLayer.setStyle({ color: ISO_COLOR });
    });

    document.getElementById("rebuild").addEventListener("click", () => {
      rebuildIsodensity(cachedPoints);
    });

    document.getElementById("exportPng").addEventListener("click", () => {
      exportMapPNG();
    });

    document.getElementById("toggleRivers").addEventListener("change", (e) => {
      setLayerVisible(layerRivers, e.target.checked);
    });

    document.getElementById("toggleRiversOut").addEventListener("change", (e) => {
      setLayerVisible(layerRiversOut, e.target.checked);
    });

    document.getElementById("toggleRoutes").addEventListener("change", (e) => {
      setLayerVisible(layerRoutes, e.target.checked);
    });

    document.getElementById("toggleLakes").addEventListener("change", (e) => {
      setLayerVisible(layerLakes, e.target.checked);
    });

    document.getElementById("togglePlaces").addEventListener("change", (e) => {
      setLayerVisible(layerPlaces, e.target.checked);
    });

    document.getElementById("toggleIso").addEventListener("change", (e) => {
      const on = e.target.checked;
      if (!isoLayer) return;
      setLayerVisible(isoLayer, on);
    });

    document.getElementById("toggleCredit").addEventListener("change", (e) => {
      document.getElementById("printCredit").style.display = e.target.checked ? "block" : "none";
    });

    document.getElementById("toggleFinds").addEventListener("change", (e) => {
      if (!layerFinds) return;
      setLayerVisible(layerFinds, e.target.checked);
    });

    document.getElementById("findRadius").addEventListener("input", () => {
      if (!cachedPoints.length) return;
      buildFindsLayer(cachedPoints);
    });

    document.getElementById("findOpacity").addEventListener("input", () => {
      if (!cachedPoints.length) return;
      buildFindsLayer(cachedPoints);
    });

    // Appliquer état initial des cases
    setLayerVisible(layerRivers, document.getElementById("toggleRivers").checked);
    setLayerVisible(layerRiversOut, document.getElementById("toggleRiversOut").checked);
    setLayerVisible(layerRoutes, document.getElementById("toggleRoutes").checked);
    setLayerVisible(layerLakes, document.getElementById("toggleLakes").checked);
    setLayerVisible(layerPlaces, document.getElementById("togglePlaces").checked);

    // -------------------------------------------------------------------------
    // CSV parsing
    // -------------------------------------------------------------------------
    function isValidLatLng(lat, lon) {
      return (
        typeof lat === "number" && typeof lon === "number" &&
        isFinite(lat) && isFinite(lon) &&
        lat >= -90 && lat <= 90 &&
        lon >= -180 && lon <= 180
      );
    }

    function parseCSV(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if (lines.length < 2) return [];

      const header = lines[0].split(",").map(s => s.trim().toLowerCase());
      const latIdx = header.indexOf("lat");
      const lonIdx = header.indexOf("lon");

      if (latIdx < 0 || lonIdx < 0) {
        throw new Error("CSV: colonnes lat/lon introuvables (attendu: LAT,LON ou lat,lon).");
      }

      const out = [];
      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(",").map(s => s.trim());
        const lat = Number(parts[latIdx]);
        const lon = Number(parts[lonIdx]);
        if (isValidLatLng(lat, lon)) out.push({ lat, lon });
      }
      return out;
    }

    // -------------------------------------------------------------------------
    // Heatmap
    // -------------------------------------------------------------------------
    function drawHeat(points) {
      if (!points || !points.length) return;

      if (heatLayer) map.removeLayer(heatLayer);

      const radius = Number(document.getElementById("heatRadius").value);
      const heatData = points.map(p => [p.lat, p.lon, 1]);

      heatLayer = L.heatLayer(heatData, {
        radius,
        blur: 22,
        maxZoom: 10,
        minOpacity: 0.05
      }).addTo(map);
    }

    // -------------------------------------------------------------------------
    // Iso-densité (grille + lissage + d3-contour)
    // -------------------------------------------------------------------------
    function kmToDegLat(km) { return km / 110.574; }
    function kmToDegLon(km, latDeg) { return km / (111.320 * Math.cos(latDeg * Math.PI / 180)); }

    function gaussianKernel1D(sigma) {
      if (sigma <= 0) return { k: [1], r: 0 };

      const r = Math.max(1, Math.round(sigma * 3));
      const k = [];
      let sum = 0;

      for (let i = -r; i <= r; i++) {
        const v = Math.exp(-(i * i) / (2 * sigma * sigma));
        k.push(v);
        sum += v;
      }

      return { k: k.map(v => v / sum), r };
    }

    function convolveSeparable(grid, nx, ny, sigma) {
      if (sigma <= 0) return grid;

      const { k, r } = gaussianKernel1D(sigma);

      const tmp = new Float32Array(nx * ny);
      for (let y = 0; y < ny; y++) {
        for (let x = 0; x < nx; x++) {
          let acc = 0;
          for (let i = -r; i <= r; i++) {
            const xx = Math.min(nx - 1, Math.max(0, x + i));
            acc += grid[y * nx + xx] * k[i + r];
          }
          tmp[y * nx + x] = acc;
        }
      }

      const out = new Float32Array(nx * ny);
      for (let y = 0; y < ny; y++) {
        for (let x = 0; x < nx; x++) {
          let acc = 0;
          for (let i = -r; i <= r; i++) {
            const yy = Math.min(ny - 1, Math.max(0, y + i));
            acc += tmp[yy * nx + x] * k[i + r];
          }
          out[y * nx + x] = acc;
        }
      }
      return out;
    }

    function buildDensityGrid(points, cellKm) {
      const lats = points.map(p => p.lat);
      const lons = points.map(p => p.lon);

      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);
      const midLat = (minLat + maxLat) / 2;

      const dLat = kmToDegLat(cellKm);
      const dLon = kmToDegLon(cellKm, midLat);

      const minLatP = minLat - dLat;
      const maxLatP = maxLat + dLat;
      const minLonP = minLon - dLon;
      const maxLonP = maxLon + dLon;

      const nx = Math.max(40, Math.min(900, Math.ceil((maxLonP - minLonP) / dLon)));
      const ny = Math.max(40, Math.min(700, Math.ceil((maxLatP - minLatP) / dLat)));

      const grid = new Float32Array(nx * ny);

      for (const p of points) {
        const x = Math.floor((p.lon - minLonP) / dLon);
        const y = Math.floor((p.lat - minLatP) / dLat);
        if (x >= 0 && x < nx && y >= 0 && y < ny) grid[y * nx + x] += 1;
      }

      return { grid, nx, ny, minLatP, minLonP, dLat, dLon };
    }

    function contoursToGeoJSON(contours, meta) {
      const { minLatP, minLonP, dLat, dLon } = meta;

      const features = contours.map(c => {
        const multipolys = c.coordinates.map(poly =>
          poly.map(ring =>
            ring.map(([x, y]) => {
              const lon = minLonP + x * dLon;
              const lat = minLatP + y * dLat;
              return [lon, lat];
            })
          )
        );

        return {
          type: "Feature",
          properties: { value: c.value },
          geometry: { type: "MultiPolygon", coordinates: multipolys }
        };
      });

      return { type: "FeatureCollection", features };
    }

    function buildFindsLayer(points) {
      if (layerFinds) map.removeLayer(layerFinds);

      const r = Number(document.getElementById("findRadius").value);
      const op = Number(document.getElementById("findOpacity").value);

      layerFinds = L.layerGroup(
        points.map(p =>
          L.circleMarker([p.lat, p.lon], {
            pane: "paneFinds",
            renderer: findsRenderer,
            radius: r,
            stroke: true,
            color: "#111",
            weight: 0.3,
            opacity: Math.min(1, op + 0.15),
            fill: true,
            fillColor: "#111",
            fillOpacity: op,
            interactive: false,
            bubblingMouseEvents: false,
          })
        )
      );

      const on = document.getElementById("toggleFinds").checked;
      if (on) layerFinds.addTo(map);
    }

    function rebuildIsodensity(points) {
      if (!points || points.length < 50) return;

      if (isoLayer) map.removeLayer(isoLayer);

      const cellKm = Number(document.getElementById("cellKm").value);
      const sigma = Number(document.getElementById("sigma").value);

      statEl.textContent = `Iso-densité : grille ${cellKm} km, sigma ${sigma}…`;

      const meta = buildDensityGrid(points, cellKm);
      let grid = meta.grid;

      grid = convolveSeparable(grid, meta.nx, meta.ny, sigma);

      const useLog = document.getElementById("toggleLog")?.checked;

      if (useLog) {
        for (let i = 0; i < grid.length; i++) {
          grid[i] = Math.log1p(grid[i]);
        }
      }

      const maxV = grid.reduce((m, v) => Math.max(m, v), 0);
      const base = Math.max(1, maxV / 10);

      const thresholds = [];
      for (let i = 1; i <= 7; i++) thresholds.push(base * i);

      const contourGen = d3.contours()
        .size([meta.nx, meta.ny])
        .thresholds(thresholds);

      const contours = contourGen(grid);
      const fc = contoursToGeoJSON(contours, meta);

      isoLayer = L.geoJSON(fc, {
        pane: "paneIso",  // Utiliser le pane dédié aux isolignes
        style: () => ({
          color: ISO_COLOR,
          weight: ISO_WEIGHT,
          opacity: ISO_OPACITY,
          fillOpacity: 0
        })
      }).addTo(map);

      statEl.textContent =
        `OK : ${points.length.toLocaleString()} points | grille ${meta.nx}×${meta.ny} | max densité ~ ${maxV.toFixed(1)}`;
    }

    // -------------------------------------------------------------------------
    // Export PNG (NOUVELLE MÉTHODE avec html2canvas)
    // -------------------------------------------------------------------------
    async function exportMapPNG() {
      statEl.textContent = "Export PNG HD en cours…";

      const mapDiv = document.getElementById("map");
      const toolbar = document.querySelector(".toolbar");
      
      // Masquer la toolbar temporairement
      toolbar.style.display = "none";

      const oldW = mapDiv.style.width;
      const oldH = mapDiv.style.height;

      // Redimensionner pour export HD
      mapDiv.style.width = "3600px";
      mapDiv.style.height = "2400px";
      
      map.invalidateSize(true);
      updatePrintScale();

      // Attendre que tout soit rendu (important pour Canvas)
      await new Promise(r => setTimeout(r, 2000));

      try {
        const canvas = await html2canvas(mapDiv, {
          useCORS: true,
          allowTaint: true,
          backgroundColor: "#ffffff",
          scale: 1,
          logging: false,
          width: 3600,
          height: 2400
        });

        // Restaurer les dimensions
        mapDiv.style.width = oldW;
        mapDiv.style.height = oldH;
        map.invalidateSize(true);
        toolbar.style.display = "block";

        // Télécharger l'image
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "cmra_carte_hd.png";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);

          statEl.textContent = "PNG téléchargé (cmra_carte_hd.png).";
        }, "image/png");

      } catch (e) {
        mapDiv.style.width = oldW;
        mapDiv.style.height = oldH;
        map.invalidateSize(true);
        toolbar.style.display = "block";

        console.error(e);
        statEl.textContent = "Export échoué (voir console).";
      }
    }

    // -------------------------------------------------------------------------
    // Main
    // -------------------------------------------------------------------------
    async function main() {
      const res = await fetch("./points.csv");
      if (!res.ok) throw new Error("Impossible de charger points.csv");

      const text = await res.text();
      const points = parseCSV(text);
      cachedPoints = points;

      const AUTO_FIT = false;

      if (AUTO_FIT && points.length) {
        const bounds = L.latLngBounds(points.map(p => [p.lat, p.lon]));
        map.fitBounds(bounds.pad(0.15));
      }

      drawHeat(points);
      buildFindsLayer(points);
      rebuildIsodensity(points);
    }

    main().catch(err => {
      console.error(err);
      statEl.textContent = "Erreur : " + (err?.message ?? err);
    });
  </script>
</body>
</html>
